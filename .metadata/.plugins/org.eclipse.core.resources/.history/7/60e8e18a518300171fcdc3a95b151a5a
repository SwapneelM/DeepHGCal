/*
 * Transform.cpp
 *
 *  Created on: 6 Aug 2017
 *      Author: user
 */

#include "../include/Transformer.h"
#include <numeric>
#include <map>
#include <stack>
#include <algorithm>
#include <iterator>
#include <iostream>
#include <string>
#include <limits>
#include <cmath>

#define LAYER_NUM 52

using namespace std;

Transformer::Transformer(vector<float> *rechit_x, vector<float> *rechit_y, converter* c)
{
	cout << "dx:" << endl;
    _DX_per_layer = this->find_dx(rechit_x, c);
	cout << "dy:" << endl;
    _DY_per_layer = this->find_dx(rechit_y, c);

	//each value is the origins coordinate in the respective layer and axis

	cout << "origins_x:" << endl;
	_origin_x = get_layer_origins(rechit_x, c);
	cout << "origins_y:" << endl;
	_origin_y = get_layer_origins(rechit_y, c);

}


vector<float> Transformer::transform(float x, float y, int layer ) const
{
//	float a = round((x - _origin_x[layer]) / _DX_per_layer[layer]);
//	float b = round((y - _origin_y[layer]) / _DY_per_layer[layer]);

	float a = (x - _origin_x[layer]) /  _DX_per_layer[layer];
	float b = (y - _origin_y[layer]) /  _DY_per_layer[layer];

	a = (int(round(b)) % 2 == 0) ? a :  (a - (0.5 * _DX_per_layer[layer]));

	vector<float> ret = {a, b};


//	cout << "x = " << to_string(x) << ", a = " << to_string(a) << ", y = " << to_string(y) <<
//			", b = " << to_string(b) << ", layer = " << to_string(layer) << endl;

	return ret;
}

vector<float> Transformer::get_layer_origins(vector<float> *rechit, converter* c)
{

	vector<float> origins;
    map<int, vector<float>> hits_by_layer = get_hits_by_layer(rechit, c);

	for (int i_layer = 0; i_layer < LAYER_NUM; i_layer++)
	{
    	if(hits_by_layer.find(i_layer) != hits_by_layer.end())
    	{
    		vector<float> layer = hits_by_layer[i_layer];

    		if (layer.size() > 0){
    			origins.push_back(accumulate(layer.begin(), layer.end(), 0.0) / layer.size());
    		}
    		else
    		{
    			cout << "layer " << to_string(i_layer) << " is empty" << endl;
    			origins.push_back(0);
    		}
    	}
    	else
    	{
    		origins.push_back(0);
    	}
	}

	for (auto i: origins)
	      std::cout << to_string(i) << ' ';
	cout << "" << endl;

    return origins;
}


//Transformer::~Transformer() {
	// TODO Auto-generated destructor stub
//}


vector<float> Transformer::find_dx(vector<float>* rechit, converter* c)
{
	//vector of hexagon unit width per layer
    vector<float> dx;

    //maps hits to corresponding layer
    map<int, vector<float>> hits_by_layer = get_hits_by_layer(rechit, c);

    float epsilon = numeric_limits<float>::epsilon();
    cout << "epsilon: " << epsilon << endl;
    //for each layer. find hexagon characteristic length
    for (int i_layer = 0; i_layer < LAYER_NUM; i_layer++)
    {
		float diff = numeric_limits<float>::max();

		cout << "layer" << i_layer << endl;

    	if(hits_by_layer.find(i_layer) != hits_by_layer.end())
    	{
    		vector<float> layer = hits_by_layer[i_layer];

    		sort(layer.begin(), layer.end());

			float tmp_diff = 0;

			for(unsigned int i = 1; i < layer.size(); i++)
			{
				tmp_diff = layer[i] - layer[i-1];

				if (tmp_diff <= diff && tmp_diff > epsilon){
						diff = tmp_diff;
						cout << diff << ", ";
    		    }
			}
    	}

		dx.push_back(diff);
    }

    cout << "dx size:" << to_string(dx.size()) << endl;
    for (auto i: dx)
      std::cout << to_string(i) << ' ';
    cout << "" << endl;

    return dx;
}

map<int, vector<float>> Transformer::get_hits_by_layer(vector<float> *rechit, converter* c)
{
	map<int, vector<float>> hits_by_layer;
    Long64_t nentries = c->fChain->GetEntries();
    Long64_t nb;

    //copies hits to their matching entry in the map
    for (Long64_t jentry = 0; jentry < nentries; jentry++) {
        Long64_t ientry = c->LoadTree(jentry);
        if (ientry < 0) break;
        nb = c->fChain->GetEntry(jentry);

        for(size_t i = 0; i < rechit->size(); i++){
        	hits_by_layer[c->rechit_layer->at(i)].push_back(rechit->at(i));
        }
    }

    return hits_by_layer;
}

